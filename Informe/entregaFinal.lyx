#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Trabajo Práctico Especial
\end_layout

\begin_layout Standard
Objetivo: Realizar un programa que muestre algunas de las características
 del Modo protegido de los microprocesadores de Intel.
 
\end_layout

\begin_layout Section
Implementacion
\end_layout

\begin_layout Standard
En esta seccion se explicara el funcionamiento interno del sistema operativo
 desarollado y porque se eligio tal implementacion.
\end_layout

\begin_layout Standard
Para una buena organizacion del codigo, se trato de realizar varios archivos
 que se encargarían de manejar tareas especificas(un estilo 
\begin_inset Formula $"objetoso"$
\end_inset

) y de este modo poder lograr un programa modularizado y por sobre todo
 implementable.
\end_layout

\begin_layout Standard
A continuacion se listan los archivos que se han considerado como los mas
 importantes:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Itemize

\bar under
Interrupt:
\bar default
 Cada vez que llega una iterrupcion al micro (ya sea por software o por
 harware), se ejecuta el handler correspondiente (programado en ASM) que
 se ocupa de llamar a la funcion en C que la maneja.
 Aqui es donde entra en juego el archivo Interrupt.c.
 Este contiene la logica necesaria para cada interrupcion.
\end_layout

\begin_deeper
\begin_layout Standard
Actualmente solo se manejan las interrupciones 
\begin_inset Formula $80h$
\end_inset

, 
\begin_inset Formula $9$
\end_inset


\begin_inset Formula $(teclado)$
\end_inset

, y la 
\begin_inset Formula $8$
\end_inset


\begin_inset Formula $(timer$
\end_inset

 
\begin_inset Formula $tick)$
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\bar under
Keyboard:
\bar default
 Luego de leido el scanCode de la tecla presionada (desde el manejador de
 la interrupcion correspondiente), se 
\begin_inset Quotes eld
\end_inset

avisa
\begin_inset Quotes erd
\end_inset

 a este archivo el scanCode y este se encarga de guardar el caracter que
 corresponda en el buffer del teclado.
\end_layout

\begin_deeper
\begin_layout Standard
Para el buffer de teclado de decidió implementar un buffer circular, en
 donde cada vez que llega un caracter, se agrega al a continuacion del anterior.
 Esto tiene la ventaja que nunca hace falta limpiar el buffer ya que aunque
 se llene, solo hay que 
\begin_inset Quotes eld
\end_inset

tomar
\begin_inset Quotes erd
\end_inset

 las caracteres no leidos del buffer para que automaticamente se haga lugar
 para las nuevas.
\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\bar under
Video:
\bar default
 Funciona como un controlador de video.
 Es el encargado de administrar el la porcion de memoria asigada a memoria.
 Ya que por cada caracter que se quiera mostrar, hay que decidir en que
 columna hay que ponerlo, en que fila y con que colores, se decidió que
 seria muy útil tener este controlador.
 Siempre que por 
\begin_inset Formula $io$
\end_inset

 se indica que se quiere escribir un buffer por la 
\begin_inset Formula $salida$
\end_inset

 
\begin_inset Formula $estadard$
\end_inset

, se llama a este controlador para que se graben adecuadamente.
\end_layout

\begin_deeper
\begin_layout Standard
Si bien en memoria el sector destinado para la pantalla es contínuo, se
 implemto todo como si se estuviese trabajando sobre una matriz (
\begin_inset Formula $getCurrRow()$
\end_inset

 y 
\begin_inset Formula $getCurrColumn()$
\end_inset

 se encargan de realizar las transormaciones matematicas correspondientes).
\begin_inset Newline newline
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\bar under
Shell:
\bar default
 Se encarga de tomar los caracteres del buffer del teclado (siempre que
 los halla) y decidir si se muestran o no en pantalla.
 En la actual implementacion, se tiene una shell con un buffer de tamaño
 fijo en donde se van guardando los caracteres tomados del buffer del teclado.
 Cuando el usuario indica que quiere ejecutar el comando ingresado, se busca
 si lo escrito coincide con el nombre de algún comando que tiene guardado
 internamente en el vector de comandos.
\end_layout

\begin_deeper
\begin_layout Itemize
Vector de comandos: Es un vector de estructuras en donde cada elemento es
 una estructua que contiene: nombre de comando, puntero a la funcion que
 ejecuta dicho comando y un char* que es la ayuda del comando.
\end_layout

\begin_layout Standard
Actualmente la shell es capaz de aceptar argumentos por linea de comandos.
 Esto fue logrado con relativa facilidad gracias a que se convino que todos
 los comandos recibirian los mismos argumentos, por lo que, visto desde
 esta perspectiva, invocar a uno u otro comando con los argumentos tomados
 es indiferente.
\end_layout

\end_deeper
\begin_layout Itemize

\bar under
Commands:
\bar default
 Aqui se encuentra la rutina de cada comando mencionado en el punto anterior.
 Para ver una lista de comandos que se ofrecen basta ejecutar 
\begin_inset Formula $“help”$
\end_inset

.
\end_layout

\begin_layout Itemize

\bar under
Kernel: 
\bar default
Esta es la parte mas imprtante de la implentacion ya que, siempre que se
 desea realiza un 
\begin_inset Formula $read$
\end_inset

 o un 
\begin_inset Formula $write$
\end_inset

, es realizado siempre a traves de este.
\end_layout

\begin_deeper
\begin_layout Standard
Tal como sugeria el archivo 
\begin_inset Formula $kernel.h$
\end_inset

 suministrado por la cetdra, se ofrecen dos metodos, __
\begin_inset Formula $read$
\end_inset

 y __
\begin_inset Formula $write$
\end_inset

.
 Uno de los parametros requeridos, es el 
\begin_inset Formula $file$
\end_inset

 
\begin_inset Formula $descriptor$
\end_inset

 que indica a donde que quiere acceder.
 Actualmente se tienen implementados 
\begin_inset Formula $tres$
\end_inset

 tipos de 
\begin_inset Formula $file$
\end_inset

 
\begin_inset Formula $descriptors$
\end_inset

:
\end_layout

\begin_layout Itemize
Si se quiere escribir en 
\begin_inset Formula $pantalla$
\end_inset

, se realiza un __
\begin_inset Formula $write$
\end_inset

 con parámetro 
\begin_inset Formula $STD$
\end_inset

_
\begin_inset Formula $OUT$
\end_inset

 o bien 
\begin_inset Formula $STD$
\end_inset

_
\begin_inset Formula $ERR$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Si se quiere leer del 
\begin_inset Formula $teclado$
\end_inset

, se realiza un __
\begin_inset Formula $read$
\end_inset

 con parámetro 
\begin_inset Formula $STD$
\end_inset

_
\begin_inset Formula $IN$
\end_inset

.
\end_layout

\begin_layout Standard
Cada vez que alguna de estas funciones es invocada, se ejectua un _
\begin_inset Formula $SystemCall$
\end_inset

 (llamda a ASM) quien se ocupa de invocar a la interupcion 
\begin_inset Formula $int80h$
\end_inset

 y esta es majedada (como ya se menciono) por el 
\begin_inset Formula $int80$
\end_inset

 
\begin_inset Formula $handler$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
Manual de uso
\end_layout

\begin_layout Standard
Para ver cuales son los comandos disponibles, basta con ejecutar el comando
 
\begin_inset Formula $help$
\end_inset

.
\end_layout

\begin_layout Standard
Para ejecutar cualquier comando valido, basta escribir 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $nombreComando$
\end_inset

 
\begin_inset Formula $argumentos$
\end_inset

 
\begin_inset Formula $separados$
\end_inset

 
\begin_inset Formula $por$
\end_inset

 
\begin_inset Formula $espacios$
\end_inset


\begin_inset Quotes erd
\end_inset

 por ej, si se invoca al comando 
\begin_inset Formula $help$
\end_inset

 
\begin_inset Formula $random$
\end_inset

, se desplegara un menu con una breve explicacion de como funciona el comando
 random.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection
Comandos actualmente disponibles:
\end_layout

\begin_layout Itemize
help
\end_layout

\begin_layout Itemize
echo
\end_layout

\begin_layout Itemize
restart
\end_layout

\begin_layout Itemize
clear
\end_layout

\begin_layout Itemize
getCPUspeed
\end_layout

\begin_layout Itemize
countDown
\end_layout

\begin_layout Itemize
setPit
\end_layout

\begin_layout Itemize
resetPit
\end_layout

\begin_layout Itemize
random
\end_layout

\begin_layout Itemize
setAppareance
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Observaciones: 
\end_layout

\begin_layout Itemize
Notar que se considera a cada espacio como un nuevo argumento.
 Por lo que la invoacion a una funcion con varios espacios en entre los
 argumentos, es lo mismo que mandar un argumento 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 (char * apuntando a un 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
'
\backslash
0'
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
) en el medio.
 
\end_layout

\begin_layout Itemize
Si se colocan espacios al principio de cada comando, el resultado final
 no debe esperarse igual a que poner el comando sin los espacios.
 Es decir: 
\begin_inset Quotes erd
\end_inset

 echo
\begin_inset Quotes erd
\end_inset

 no va a ejecutar el comando llamado 
\begin_inset Quotes eld
\end_inset

echo
\begin_inset Quotes erd
\end_inset

 (sin espacio al principio)
\end_layout

\begin_layout Section
CPU Speed
\end_layout

\begin_layout Standard
Para el calculo de la velocidad de la CPU se decidió calcular cuantas veces
 se llegaba a incrementar una variable entre dos timerTicks.
 Es decir, calculamos la cantidad de 
\begin_inset Formula $iteracciones$
\end_inset

 que la CPU es capaz de realizar en este intervalo tiempo.
 Sin embargo, como este valor puede llegar a variar en cada mdicion ya que
 la CPU puede estar mas o menos ocupada, se decidió que lo mejor era realizar
 
\begin_inset Formula $N$
\end_inset

 mediciones y luego calcular el promedio de las mismas.
 
\end_layout

\end_body
\end_document
